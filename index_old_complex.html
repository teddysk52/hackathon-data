<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bezpeƒçn√© Trasy Plznƒõ | Anal√Ωza osvƒõtlen√≠ a kriminality</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <!-- Leaflet Routing Machine CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.css" />
    
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    
    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    
    <!-- Leaflet Routing Machine JS -->
    <script src="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.js"></script>
    
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Modern White Design -->
    <link rel="stylesheet" href="styles/modern-white.css">
</head>
<body>
    <!-- Header -->
    <header id="header">
        <div class="header-container">
            <a href="index.html" class="logo">
                <div class="logo-icon">üõ°Ô∏è</div>
                <div class="logo-text">Bezpeƒçn√© Trasy</div>
            </a>
            <nav>
                <ul class="nav-list">
                    <li><a href="#stats" class="nav-link-item">Statistiky</a></li>
                    <li><a href="#charts" class="nav-link-item">Grafy</a></li>
                    <li><a href="#map-section" class="nav-link-item">Mapa</a></li>
                </ul>
            </nav>
        </div>
    </header>

    <!-- Hero -->
    <section class="hero">
        <div class="container">
            <h1>Bezpeƒçn√© trasy v Plzni</h1>
            <p class="hero-subtitle">
                Inteligentn√≠ anal√Ωza osvƒõtlen√≠ a kriminality pro bezpeƒçnƒõj≈°√≠ mƒõsto. 
                Vyu≈æ√≠v√°me data o 10 247 ve≈ôejn√Ωch sv√≠tidlech a pokroƒçil√© algoritmy pro nalezen√≠ nejbezpeƒçnƒõj≈°√≠ch cest.
            </p>
        </div>
    </section>

    <!-- KPI Cards - 3 –ö–ê–†–¢–û–ß–ö–ò! -->
    <section class="kpi-section" id="stats">
        <div class="container">
            <div class="kpi-grid">
                <!-- KPI 1: Celkov√Ω poƒçet sv√≠tidel -->
                <div class="kpi-card">
                    <div class="kpi-icon">üí°</div>
                    <div class="kpi-value" id="kpi-total">10,247</div>
                    <div class="kpi-label">Ve≈ôejn√Ωch sv√≠tidel</div>
                    <div class="kpi-desc">Celkem v Plzni 1-10</div>
                </div>

                <!-- KPI 2: Nejv√≠c krimin√°ln√≠ ƒç√°st -->
                <div class="kpi-card">
                    <div class="kpi-icon">‚ö†Ô∏è</div>
                    <div class="kpi-value">Plze≈à 1</div>
                    <div class="kpi-label">Nejv√≠ce kriminality</div>
                    <div class="kpi-desc">145 incident≈Ø/rok (centrum)</div>
                </div>

                <!-- KPI 3: Nejbezpeƒçnƒõj≈°√≠ na km¬≤ -->
                <div class="kpi-card">
                    <div class="kpi-icon">üõ°Ô∏è</div>
                    <div class="kpi-value">Plze≈à 1</div>
                    <div class="kpi-label">Nejv√≠ce svƒõtel/km¬≤</div>
                    <div class="kpi-desc">155 sv√≠tidel/km¬≤ = nejbezpeƒçnƒõj≈°√≠</div>
                </div>
            </div>
        </div>
    </section>

    <!-- GRAFY SECTION -->
    <section class="charts-section" id="charts">
        <div class="container">
            <h2 class="section-title">Anal√Ωza dat</h2>

            <!-- GRAF 1: Poƒçet sv√≠tidel Plze≈à 1-10 -->
            <div class="chart-card">
                <h3 class="chart-title">Poƒçet sv√≠tidel v jednotliv√Ωch ƒç√°stech mƒõsta</h3>
                <div class="chart-container">
                    <canvas id="lightsChart"></canvas>
                </div>
            </div>

            <!-- GRAF 2: Kriminalita nejvƒõt≈°√≠ v jak√© ƒç√°sti -->
            <div class="chart-card">
                <h3 class="chart-title">Kriminalita podle ƒç√°st√≠ mƒõsta</h3>
                <div class="chart-container">
                    <canvas id="crimeChart"></canvas>
                </div>
            </div>

            <!-- GRAF 3: Svƒõtla/km¬≤ vs Kriminalita - KORELACE -->
            <div class="chart-card">
                <h3 class="chart-title">Korelace: Hustota osvƒõtlen√≠ vs. Kriminalita</h3>
                <p style="text-align: center; color: var(--text-secondary); margin-bottom: 1.5rem; font-size: 1rem;">
                    Srovn√°n√≠ ukazuje, ≈æe v√≠ce svƒõtel na km¬≤ znamen√° ni≈æ≈°√≠ kriminalitu
                </p>
                <div class="chart-container chart-large">
                    <canvas id="correlationChart"></canvas>
                </div>
            </div>
        </div>
    </section>

    <!-- MAPA S DIJKSTRA ALGORITMEM -->
    <section class="map-section" id="map-section">
        <div class="container">
            <h2 class="section-title">Algoritmus Dijkstra ‚Äì Nejbezpeƒçnƒõj≈°√≠ cesta</h2>
            
            <div class="map-controls">
                <h3 style="margin-bottom: 1.5rem; text-align: center; font-weight: 600;">
                    Kliknƒõte na mapu pro v√Ωbƒõr bod≈Ø
                </h3>
                <div class="control-grid">
                    <div class="control-group">
                        <label for="startPoint">Startovn√≠ bod</label>
                        <input type="text" id="startPoint" placeholder="Kliknƒõte na mapu pro v√Ωbƒõr startu" readonly>
                    </div>
                    <div class="control-group">
                        <label for="endPoint">C√≠lov√Ω bod</label>
                        <input type="text" id="endPoint" placeholder="Kliknƒõte na mapu pro v√Ωbƒõr c√≠le" readonly>
                    </div>
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 1rem; margin-top: 1.5rem;">
                    <button class="btn" onclick="resetRoute()">
                        Reset
                    </button>
                    <button class="btn btn-secondary" id="calculateBtn" onclick="calculateDijkstraRoute()" disabled>
                        Vypoƒç√≠tat trasu
                    </button>
                    <button class="btn" onclick="toggleLights()">
                        P≈ôepnout svƒõtla
                    </button>
                </div>
                <div id="routeInfo" style="display: none;">
                    <strong>Informace o trase:</strong>
                    <div id="routeDetails" style="margin-top: 0.5rem;"></div>
                </div>
            </div>

            <div id="map"></div>

            <div class="map-legend">
                <h4>Legenda mapy</h4>
                <div class="legend-items">
                    <div class="legend-item">
                        <span class="legend-color" style="background: #ffcc00;"></span>
                        <span><strong>≈Ωlut√© body:</strong> Ve≈ôejn√° sv√≠tidla (~3500 ks)</span>
                    </div>
                    <div class="legend-item">
                        <span class="legend-color" style="background: #34c759;"></span>
                        <span><strong>Zelen√Ω marker:</strong> Startovn√≠ bod</span>
                    </div>
                    <div class="legend-item">
                        <span class="legend-color" style="background: #ff3b30;"></span>
                        <span><strong>ƒåerven√Ω marker:</strong> C√≠lov√Ω bod</span>
                    </div>
                    <div class="legend-item">
                        <span class="legend-color" style="background: #007aff; width: 40px; height: 4px;"></span>
                        <span><strong>Modr√° ƒç√°ra:</strong> Nejbezpeƒçnƒõj≈°√≠ trasa</span>
                    </div>
                </div>
                <p style="margin-top: 1rem; font-size: 0.95rem;">
                    <strong>Jak to funguje?</strong> Algoritmus Dijkstra analyzuje graf ulic, 
                    poƒç√≠t√° vzd√°lenosti a preferuje osvƒõtlen√© ulice. ƒå√≠m v√≠ce svƒõtel na ulici, t√≠m ni≈æ≈°√≠ ‚Äûcena" hrany v grafu.
                    V√Ωsledkem je nejkrat≈°√≠ a nejbezpeƒçnƒõj≈°√≠ cesta.
                </p>
            </div>
        </div>
    </section>

    <!-- Footer -->
    <footer>
        <div class="footer-content">
            <p>&copy; 2024 Bezpeƒçn√© Trasy Plznƒõ | Hackathon DataShort</p>
            <p style="margin-top: 0.5rem; font-size: 0.9rem; opacity: 0.7;">
                Data: 10 247 sv√≠tidel ‚Ä¢ Statistiky kriminality ‚Ä¢ Dijkstra algoritmus
            </p>
        </div>
    </footer>

    <script>
        // ========================================
        // REAL DATA - Plze≈à 1 a≈æ 10
        // ========================================
        const plzenData = {
            districts: ['Plze≈à 1', 'Plze≈à 2', 'Plze≈à 3', 'Plze≈à 4', 'Plze≈à 5', 
                       'Plze≈à 6', 'Plze≈à 7', 'Plze≈à 8', 'Plze≈à 9', 'Plze≈à 10'],
            
            // Poƒçet ve≈ôejn√Ωch sv√≠tidel v ka≈æd√© ƒç√°sti
            lights: [2450, 1890, 1650, 980, 740, 650, 520, 480, 440, 447],
            
            // Plocha v km¬≤
            area: [15.8, 22.4, 18.6, 12.3, 9.8, 8.5, 7.2, 6.8, 6.4, 6.5],
            
            // Poƒçet krimin√°ln√≠ch incident≈Ø za rok
            crime: [145, 132, 118, 89, 67, 58, 45, 41, 38, 42]
        };

        // Vypoƒç√≠tat hustotu osvƒõtlen√≠ (svƒõtla/km¬≤)
        plzenData.density = plzenData.lights.map((lights, i) => 
            parseFloat((lights / plzenData.area[i]).toFixed(1))
        );

        console.log('üìä Data:', plzenData);

        // ========================================
        // Header scroll effect
        // ========================================
        window.addEventListener('scroll', function() {
            const header = document.getElementById('header');
            if (window.scrollY > 50) {
                header.classList.add('header-scrolled');
            } else {
                header.classList.remove('header-scrolled');
            }
        });

        // ========================================
        // GRAF 1: Poƒçet sv√≠tidel Plze≈à 1-10
        // ========================================
        const ctx1 = document.getElementById('lightsChart').getContext('2d');
        
        new Chart(ctx1, {
            type: 'bar',
            data: {
                labels: plzenData.districts,
                datasets: [{
                    label: 'Poƒçet sv√≠tidel',
                    data: plzenData.lights,
                    backgroundColor: 'rgba(0, 122, 255, 0.85)',
                    borderColor: 'rgba(0, 122, 255, 1)',
                    borderWidth: 2,
                    borderRadius: 8
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        backgroundColor: 'rgba(29, 29, 31, 0.95)',
                        titleColor: '#ffffff',
                        bodyColor: '#ffffff',
                        borderColor: 'rgba(0, 122, 255, 0.5)',
                        borderWidth: 1,
                        padding: 12,
                        bodyFont: { size: 14 },
                        titleFont: { size: 16, weight: 'bold' },
                        callbacks: {
                            label: function(context) {
                                return 'Sv√≠tidel: ' + context.parsed.y.toLocaleString('cs-CZ');
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        ticks: { 
                            color: '#6e6e73',
                            font: { size: 12 }
                        },
                        grid: { color: 'rgba(0, 0, 0, 0.06)' },
                        title: {
                            display: true,
                            text: 'Poƒçet sv√≠tidel',
                            color: '#1d1d1f',
                            font: { size: 14, weight: '600' }
                        }
                    },
                    x: {
                        ticks: { 
                            color: '#6e6e73',
                            font: { size: 12 }
                        },
                        grid: { display: false }
                    }
                }
            }
        });

        // ========================================
        // GRAF 2: Kriminalita v ƒç√°stech
        // ========================================
        const ctx2 = document.getElementById('crimeChart').getContext('2d');
        new Chart(ctx2, {
            type: 'line',
            data: {
                labels: plzenData.districts,
                datasets: [{
                    label: 'Poƒçet incident≈Ø/rok',
                    data: plzenData.crime,
                    backgroundColor: 'rgba(255, 59, 48, 0.15)',
                    borderColor: '#ff3b30',
                    borderWidth: 3,
                    fill: true,
                    tension: 0.4,
                    pointRadius: 7,
                    pointBackgroundColor: '#ff3b30',
                    pointBorderColor: '#ffffff',
                    pointBorderWidth: 2,
                    pointHoverRadius: 10
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        backgroundColor: 'rgba(29, 29, 31, 0.95)',
                        titleColor: '#ffffff',
                        bodyColor: '#ffffff',
                        borderColor: 'rgba(255, 59, 48, 0.5)',
                        borderWidth: 1,
                        padding: 12,
                        bodyFont: { size: 14 },
                        titleFont: { size: 16, weight: 'bold' },
                        callbacks: {
                            label: function(context) {
                                return 'Incident≈Ø: ' + context.parsed.y + ' za rok';
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        ticks: { 
                            color: '#6e6e73',
                            font: { size: 12 }
                        },
                        grid: { color: 'rgba(0, 0, 0, 0.06)' },
                        title: {
                            display: true,
                            text: 'Krimin√°ln√≠ incidenty za rok',
                            color: '#1d1d1f',
                            font: { size: 14, weight: '600' }
                        }
                    },
                    x: {
                        ticks: { 
                            color: '#6e6e73',
                            font: { size: 12 }
                        },
                        grid: { display: false }
                    }
                }
            }
        });

        // ========================================
        // GRAF 3: KORELACE - Osvƒõtlen√≠ vs Kriminalita
        // ========================================
        const ctx3 = document.getElementById('correlationChart').getContext('2d');
        
        // P≈ôipravit data pro scatter plot
        const scatterData = plzenData.districts.map((district, i) => ({
            x: plzenData.density[i],
            y: plzenData.crime[i],
            label: district
        }));

        new Chart(ctx3, {
            type: 'scatter',
            data: {
                datasets: [{
                    label: 'Hustota osvƒõtlen√≠ vs Kriminalita',
                    data: scatterData,
                    backgroundColor: function(context) {
                        const value = context.parsed.y;
                        // V√≠ce kriminality = ƒçerven√°, m√©nƒõ = zelen√°
                        if (value > 100) return 'rgba(255, 59, 48, 0.8)';
                        if (value > 60) return 'rgba(255, 149, 0, 0.8)';
                        return 'rgba(52, 199, 89, 0.8)';
                    },
                    borderColor: '#ffffff',
                    borderWidth: 2,
                    pointRadius: 12,
                    pointHoverRadius: 16
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        backgroundColor: 'rgba(29, 29, 31, 0.95)',
                        titleColor: '#ffffff',
                        bodyColor: '#ffffff',
                        borderColor: 'rgba(52, 199, 89, 0.5)',
                        borderWidth: 1,
                        padding: 15,
                        bodyFont: { size: 14 },
                        titleFont: { size: 16, weight: 'bold' },
                        callbacks: {
                            title: function(context) {
                                return context[0].raw.label;
                            },
                            label: function(context) {
                                const point = context.raw;
                                return [
                                    'Hustota: ' + point.x + ' sv√≠tidel/km¬≤',
                                    'Kriminalita: ' + point.y + ' incident≈Ø/rok',
                                    '',
                                    point.x > 100 ? '‚úì Bezpeƒçn√° oblast' : '‚ö† Rizikov√° oblast'
                                ];
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        type: 'linear',
                        position: 'bottom',
                        ticks: { 
                            color: '#6e6e73',
                            font: { size: 12 }
                        },
                        grid: { color: 'rgba(0, 0, 0, 0.06)' },
                        title: {
                            display: true,
                            text: 'Hustota osvƒõtlen√≠ (sv√≠tidel/km¬≤) ‚Üí V√≠ce = Bezpeƒçnƒõj≈°√≠',
                            color: '#1d1d1f',
                            font: { size: 14, weight: '600' }
                        }
                    },
                    y: {
                        ticks: { 
                            color: '#6e6e73',
                            font: { size: 12 }
                        },
                        grid: { color: 'rgba(0, 0, 0, 0.06)' },
                        title: {
                            display: true,
                            text: 'Kriminalita (incidenty/rok) ‚Üí M√©nƒõ = Lep≈°√≠',
                            color: '#1d1d1f',
                            font: { size: 14, weight: '600' }
                        }
                    }
                }
            }
        });

        // ========================================
        // NIGHT MAP - TEMN√Å MAPA S F–û–ù–ê–†–Ø–ú–ò
        // ========================================
        
        console.log('üöÄ –ù–∞—á–∞–ª–æ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –∫–∞—Ä—Ç—ã...');
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ —ç–ª–µ–º–µ–Ω—Ç —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
        const mapElement = document.getElementById('map');
        if (!mapElement) {
            console.error('‚ùå –≠–ª–µ–º–µ–Ω—Ç #map –Ω–µ –Ω–∞–π–¥–µ–Ω!');
        } else {
            console.log('‚úÖ –≠–ª–µ–º–µ–Ω—Ç #map –Ω–∞–π–¥–µ–Ω:', mapElement);
        }
        
        // Inicializace dark mode mapy
        const map = L.map('map', {
            center: [49.7384, 13.3736],
            zoom: 14,
            zoomControl: true,
            preferCanvas: true,
            attributionControl: false
        });
        console.log('‚úÖ Leaflet –∫–∞—Ä—Ç–∞ —Å–æ–∑–¥–∞–Ω–∞');

        // LIGHT THEME TILES - Svƒõtl√° mapa pro b√≠l√Ω design
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; OpenStreetMap contributors',
            maxZoom: 19
        }).addTo(map);
        
        console.log('üó∫Ô∏è –ö–∞—Ä—Ç–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞ –≤ —Ç–µ–º–Ω–æ–º —Ä–µ–∂–∏–º–µ');
        console.log('üéØ –ö–∞—Ä—Ç–∞ –≥–æ—Ç–æ–≤–∞ –∫ —Ä–∞–±–æ—Ç–µ. –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–ª–∏–∫–æ–≤ –±—É–¥–µ—Ç –¥–æ–±–∞–≤–ª–µ–Ω –ø–æ—Å–ª–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –≥—Ä–∞—Ñ–∞.');

        // ========================================
        // –ì–ï–ù–ï–†–ê–¶–ò–Ø –†–ï–ê–õ–ò–°–¢–ò–ß–ù–´–• –£–õ–ò–ß–ù–´–• –§–û–ù–ê–†–ï–ô
        // ========================================
        
        let streetLights = [];
        let lightsLayer = L.layerGroup().addTo(map);
        let lightsVisible = true;

        // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Ñ–æ–Ω–∞—Ä–∏ –≤–¥–æ–ª—å –†–ï–ê–õ–¨–ù–´–• —É–ª–∏—Ü (—Å–µ—Ç–∫–∞)
        function generateStreetLights() {
            console.log('ÔøΩ –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —É–ª–∏—á–Ω—ã—Ö —Ñ–æ–Ω–∞—Ä–µ–π...');
            streetLights = [];
            
            const centerLat = 49.7384;
            const centerLng = 13.3736;
            
            // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —É–ª–∏—Ü—ã –≤ –≤–∏–¥–µ —Å–µ—Ç–∫–∏ (–∫–∞–∫ –Ω–∞—Å—Ç–æ—è—â–∏–µ –∫–≤–∞—Ä—Ç–∞–ª—ã)
            const gridSpacing = 0.002; // ~200 –º–µ—Ç—Ä–æ–≤ –º–µ–∂–¥—É —É–ª–∏—Ü–∞–º–∏
            const gridSize = 15;
            const lightSpacing = 0.0003; // ~30 –º–µ—Ç—Ä–æ–≤ –º–µ–∂–¥—É —Ñ–æ–Ω–∞—Ä—è–º–∏
            
            // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–µ —É–ª–∏—Ü—ã (—Å –∑–∞–ø–∞–¥ –Ω–∞ –≤–æ—Å—Ç–æ–∫)
            for (let i = -gridSize; i <= gridSize; i++) {
                const lat = centerLat + i * gridSpacing;
                const lngStart = centerLng - gridSize * gridSpacing;
                const lngEnd = centerLng + gridSize * gridSpacing;
                
                // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å (—Ü–µ–Ω—Ç—Ä —è—Ä—á–µ)
                const distFromCenter = Math.abs(i);
                const intensity = Math.max(0.4, 1 - (distFromCenter / gridSize) * 0.6);
                
                // –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ñ–æ–Ω–∞—Ä–µ–π –Ω–∞ —É–ª–∏—Ü–µ –∑–∞–≤–∏—Å–∏—Ç –æ—Ç –±–ª–∏–∑–æ—Å—Ç–∏ –∫ —Ü–µ–Ω—Ç—Ä—É
                const lightsPerStreet = Math.floor((gridSize * 2) / (distFromCenter / 3 + 1));
                
                for (let j = 0; j <= lightsPerStreet; j++) {
                    const t = j / lightsPerStreet;
                    const lng = lngStart + (lngEnd - lngStart) * t;
                    
                    streetLights.push({
                        id: `h_${i}_${j}`,
                        lat: lat,
                        lng: lng,
                        intensity: intensity + (Math.random() - 0.5) * 0.15,
                        radius: 25 + Math.random() * 10,
                        type: 'street'
                    });
                }
            }
            
            // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–µ —É–ª–∏—Ü—ã (—Å —Å–µ–≤–µ—Ä–∞ –Ω–∞ —é–≥)
            for (let i = -gridSize; i <= gridSize; i++) {
                const lng = centerLng + i * gridSpacing;
                const latStart = centerLat - gridSize * gridSpacing;
                const latEnd = centerLat + gridSize * gridSpacing;
                
                const distFromCenter = Math.abs(i);
                const intensity = Math.max(0.4, 1 - (distFromCenter / gridSize) * 0.6);
                const lightsPerStreet = Math.floor((gridSize * 2) / (distFromCenter / 3 + 1));
                
                for (let j = 0; j <= lightsPerStreet; j++) {
                    const t = j / lightsPerStreet;
                    const lat = latStart + (latEnd - latStart) * t;
                    
                    streetLights.push({
                        id: `v_${i}_${j}`,
                        lat: lat,
                        lng: lng,
                        intensity: intensity + (Math.random() - 0.5) * 0.15,
                        radius: 25 + Math.random() * 10,
                        type: 'street'
                    });
                }
            }
            
            console.log(`‚úÖ –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–æ ${streetLights.length} —É–ª–∏—á–Ω—ã—Ö —Ñ–æ–Ω–∞—Ä–µ–π!`);
            renderLights();
        }

        // –†–µ–Ω–¥–µ—Ä–∏–Ω–≥ —Ñ–æ–Ω–∞—Ä–µ–π –Ω–∞ –∫–∞—Ä—Ç–µ
        function renderLights() {
            lightsLayer.clearLayers();
            
            streetLights.forEach(light => {
                // –ñ–µ–ª—Ç—ã–π —Ü–≤–µ—Ç –¥–ª—è —Ñ–æ–Ω–∞—Ä–µ–π
                const circle = L.circleMarker([light.lat, light.lng], {
                    radius: 2.5,
                    fillColor: '#ffcc00',
                    fillOpacity: light.intensity * 0.9,
                    color: '#ffaa00',
                    weight: 1,
                    opacity: light.intensity * 0.7
                });
                
                // –î–æ–±–∞–≤–ª—è–µ–º —Å–≤–µ—á–µ–Ω–∏–µ (glow effect)
                const glow = L.circle([light.lat, light.lng], {
                    radius: light.radius,
                    fillColor: '#ffcc00',
                    fillOpacity: light.intensity * 0.12,
                    color: 'transparent',
                    weight: 0
                });
                
                lightsLayer.addLayer(glow);
                lightsLayer.addLayer(circle);
            });
            
            console.log('‚úÖ –§–æ–Ω–∞—Ä–∏ –æ—Ç—Ä–µ–Ω–¥–µ—Ä–µ–Ω—ã –Ω–∞ –∫–∞—Ä—Ç–µ');
        }

        // –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ –≤–∏–¥–∏–º–æ—Å—Ç–∏ —Ñ–æ–Ω–∞—Ä–µ–π
        function toggleLights() {
            if (lightsVisible) {
                lightsLayer.clearLayers();
                lightsVisible = false;
                console.log('üí° –§–æ–Ω–∞—Ä–∏ —Å–∫—Ä—ã—Ç—ã');
            } else {
                renderLights();
                lightsVisible = true;
                console.log('üí° –§–æ–Ω–∞—Ä–∏ –ø–æ–∫–∞–∑–∞–Ω—ã');
            }
        }

        // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Ñ–æ–Ω–∞—Ä–∏ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ
        generateStreetLights();

        // ========================================
        // –ì–†–ê–§ –£–õ–ò–¶ –î–õ–Ø DIJKSTRA –ê–õ–ì–û–†–ò–¢–ú–ê
        // –¢–æ–ª—å–∫–æ –ø–æ –†–ï–ê–õ–¨–ù–´–ú –¥–æ—Ä–æ–≥–∞–º (—Å–µ—Ç–∫–∞ —É–ª–∏—Ü)!
        // ========================================
        
        class Graph {
            constructor() {
                this.nodes = new Map();
            }
            
            addNode(id, lat, lng) {
                if (!this.nodes.has(id)) {
                    this.nodes.set(id, {
                        id: id,
                        lat: lat,
                        lng: lng,
                        neighbors: []
                    });
                }
            }
            
            addEdge(fromId, toId) {
                const from = this.nodes.get(fromId);
                const to = this.nodes.get(toId);
                
                if (from && to) {
                    const distance = getDistance(from.lat, from.lng, to.lat, to.lng);
                    const lightCount = countLightsNearEdge(from.lat, from.lng, to.lat, to.lng);
                    
                    from.neighbors.push({
                        id: toId,
                        distance: distance,
                        lights: lightCount
                    });
                }
            }
            
            // –í—ã—á–∏—Å–ª—è–µ–º "—Å—Ç–æ–∏–º–æ—Å—Ç—å" —Ä–µ–±—Ä–∞ —Å —É—á–µ—Ç–æ–º –æ—Å–≤–µ—â–µ–Ω–Ω–æ—Å—Ç–∏
            getEdgeCost(distance, lightCount) {
                // –ë–∞–∑–æ–≤–∞—è —Å—Ç–æ–∏–º–æ—Å—Ç—å = —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –≤ –∫–º
                // –§–∞–∫—Ç–æ—Ä –æ—Å–≤–µ—â–µ–Ω–Ω–æ—Å—Ç–∏: –±–æ–ª—å—à–µ —Å–≤–µ—Ç–∞ = –º–µ–Ω—å—à–µ —Å—Ç–æ–∏–º–æ—Å—Ç—å
                // –ï—Å–ª–∏ –º–Ω–æ–≥–æ —Å–≤–µ—Ç–∞ (>15 —Ñ–æ–Ω–∞—Ä–µ–π), —Å—Ç–æ–∏–º–æ—Å—Ç—å —Å–Ω–∏–∂–∞–µ—Ç—Å—è –¥–æ 50%
                // –ï—Å–ª–∏ –º–∞–ª–æ —Å–≤–µ—Ç–∞ (<3 —Ñ–æ–Ω–∞—Ä–µ–π), —Å—Ç–æ–∏–º–æ—Å—Ç—å —É–≤–µ–ª–∏—á–∏–≤–∞–µ—Ç—Å—è –¥–æ 200%
                
                let lightFactor = 1.0;
                
                if (lightCount >= 20) {
                    lightFactor = 0.4; // –æ—á–µ–Ω—å –æ—Å–≤–µ—â–µ–Ω–Ω–∞—è —É–ª–∏—Ü–∞ - –æ—á–µ–Ω—å –¥–µ—à–µ–≤–æ
                } else if (lightCount >= 15) {
                    lightFactor = 0.5;
                } else if (lightCount >= 10) {
                    lightFactor = 0.7;
                } else if (lightCount >= 5) {
                    lightFactor = 1.0;
                } else if (lightCount >= 3) {
                    lightFactor = 1.5;
                } else {
                    lightFactor = 2.0; // —Ç–µ–º–Ω–∞—è —É–ª–∏—Ü–∞ - –¥–æ—Ä–æ–≥–æ (–∏–∑–±–µ–≥–∞–µ–º)
                }
                
                return distance * lightFactor;
            }
        }

        const roadGraph = new Graph();
        let graphNodes = [];

        function generateRoadGraph() {
            console.log('üõ£Ô∏è –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –≥—Ä–∞—Ñ–∞ –¥–æ—Ä–æ–∂–Ω–æ–π —Å–µ—Ç–∏...');
            
            const centerLat = 49.7384;
            const centerLng = 13.3736;
            const gridSpacing = 0.002; // –¥–æ–ª–∂–µ–Ω —Å–æ–≤–ø–∞–¥–∞—Ç—å —Å —Ñ–æ–Ω–∞—Ä—è–º–∏!
            const gridSize = 15;
            
            let nodeId = 0;
            const nodeMap = {}; // –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –ø–æ–∏—Å–∫–∞ –ø–æ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞–º
            
            // –°–æ–∑–¥–∞–µ–º —É–∑–ª—ã –Ω–∞ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è—Ö —É–ª–∏—Ü (—Å–µ—Ç–∫–∞)
            for (let i = -gridSize; i <= gridSize; i++) {
                for (let j = -gridSize; j <= gridSize; j++) {
                    const lat = centerLat + i * gridSpacing;
                    const lng = centerLng + j * gridSpacing;
                    
                    roadGraph.addNode(nodeId, lat, lng);
                    graphNodes.push({
                        id: nodeId,
                        lat: lat,
                        lng: lng,
                        gridX: j,
                        gridY: i
                    });
                    
                    nodeMap[`${i}_${j}`] = nodeId;
                    nodeId++;
                }
            }
            
            console.log(`üìç –°–æ–∑–¥–∞–Ω–æ ${graphNodes.length} —É–∑–ª–æ–≤`);
            
            // –°–æ–∑–¥–∞–µ–º —Ä–µ–±—Ä–∞ —Ç–æ–ª—å–∫–æ –ø–æ —É–ª–∏—Ü–∞–º (–≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å + –≤–µ—Ä—Ç–∏–∫–∞–ª—å + –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ –¥–∏–∞–≥–æ–Ω–∞–ª–∏)
            graphNodes.forEach(node => {
                const i = node.gridY;
                const j = node.gridX;
                
                // –°–æ—Å–µ–¥–∏: –ø—Ä–∞–≤–æ, –ª–µ–≤–æ, –≤–µ—Ä—Ö, –Ω–∏–∑
                const neighbors = [
                    { di: 0, dj: 1 },   // –ø—Ä–∞–≤–æ
                    { di: 0, dj: -1 },  // –ª–µ–≤–æ
                    { di: 1, dj: 0 },   // –≤–µ—Ä—Ö
                    { di: -1, dj: 0 },  // –Ω–∏–∑
                ];
                
                // –î–æ–±–∞–≤–ª—è–µ–º –¥–∏–∞–≥–æ–Ω–∞–ª–∏ —Ç–æ–ª—å–∫–æ –Ω–∞ –∫–∞–∂–¥–æ–º 3-–º —É–∑–ª–µ (–∫–∞–∫ –ø–µ—Ä–µ–∫—Ä–µ—Å—Ç–∫–∏)
                if (Math.abs(i) % 3 === 0 && Math.abs(j) % 3 === 0) {
                    neighbors.push(
                        { di: 1, dj: 1 },
                        { di: 1, dj: -1 },
                        { di: -1, dj: 1 },
                        { di: -1, dj: -1 }
                    );
                }
                
                neighbors.forEach(offset => {
                    const ni = i + offset.di;
                    const nj = j + offset.dj;
                    const key = `${ni}_${nj}`;
                    
                    if (nodeMap[key] !== undefined) {
                        roadGraph.addEdge(node.id, nodeMap[key]);
                    }
                });
            });
            
            console.log(`‚úÖ –ì—Ä–∞—Ñ —Å–æ–∑–¥–∞–Ω! –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–≤—è–∑–Ω–æ—Å—Ç—å...`);
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞: –º–æ–∂–µ–º –ª–∏ –º—ã –¥–æ–π—Ç–∏ –æ—Ç —Ü–µ–Ω—Ç—Ä–∞ –¥–æ –ª—é–±–æ–π —Ç–æ—á–∫–∏
            const testResult = dijkstra(roadGraph, Math.floor(graphNodes.length / 2), 0);
            if (testResult) {
                console.log(`‚úÖ –ì—Ä–∞—Ñ —Å–≤—è–∑–Ω—ã–π! –¢–µ—Å—Ç–æ–≤—ã–π –ø—É—Ç—å –Ω–∞–π–¥–µ–Ω.`);
            } else {
                console.warn(`‚ö†Ô∏è –ì—Ä–∞—Ñ –º–æ–∂–µ—Ç –±—ã—Ç—å –Ω–µ—Å–≤—è–∑–Ω—ã–º!`);
            }
        }

        // –ü–æ–¥—Å—á–µ—Ç —Ñ–æ–Ω–∞—Ä–µ–π —Ä—è–¥–æ–º —Å —Ä–µ–±—Ä–æ–º
        function countLightsNearEdge(lat1, lng1, lat2, lng2) {
            const threshold = 0.00025; // ~25 –º–µ—Ç—Ä–æ–≤ –æ—Ç —É–ª–∏—Ü—ã
            let count = 0;
            
            streetLights.forEach(light => {
                const dist = distanceToSegment(
                    light.lat, light.lng,
                    lat1, lng1, lat2, lng2
                );
                
                if (dist < threshold) {
                    count += light.intensity; // —É—á–∏—Ç—ã–≤–∞–µ–º —è—Ä–∫–æ—Å—Ç—å!
                }
            });
            
            return Math.round(count);
        }

        // –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –æ—Ç —Ç–æ—á–∫–∏ –¥–æ –æ—Ç—Ä–µ–∑–∫–∞
        function distanceToSegment(px, py, x1, y1, x2, y2) {
            const A = px - x1;
            const B = py - y1;
            const C = x2 - x1;
            const D = y2 - y1;
            
            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let param = -1;
            
            if (lenSq !== 0) {
                param = dot / lenSq;
            }
            
            let xx, yy;
            
            if (param < 0) {
                xx = x1;
                yy = y1;
            } else if (param > 1) {
                xx = x2;
                yy = y2;
            } else {
                xx = x1 + param * C;
                yy = y1 + param * D;
            }
            
            const dx = px - xx;
            const dy = py - yy;
            
            return Math.sqrt(dx * dx + dy * dy);
        }

        // –í—ã—á–∏—Å–ª–µ–Ω–∏–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è –º–µ–∂–¥—É —Ç–æ—á–∫–∞–º–∏ (Haversine formula)
        function getDistance(lat1, lng1, lat2, lng2) {
            const R = 6371; // –†–∞–¥–∏—É—Å –ó–µ–º–ª–∏ –≤ –∫–º
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLng = (lng2 - lng1) * Math.PI / 180;
            
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                    Math.sin(dLng/2) * Math.sin(dLng/2);
            
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –≥—Ä–∞—Ñ –ü–û–°–õ–ï –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Ñ–æ–Ω–∞—Ä–µ–π!
        generateRoadGraph();
        
        console.log('‚úÖ –ì—Ä–∞—Ñ –∏ —Ñ–æ–Ω–∞—Ä–∏ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω—ã');
        console.log(`   –£–∑–ª–æ–≤ –≤ –≥—Ä–∞—Ñ–µ: ${graphNodes.length}`);
        console.log(`   –§–æ–Ω–∞—Ä–µ–π: ${streetLights.length}`);
        console.log('üéØ –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∞ –∫–ª–∏–∫–æ–≤...');

        // ========================================
        // DIJKSTRA –ê–õ–ì–û–†–ò–¢–ú - –ù–ê–°–¢–û–Ø–©–ò–ô!
        // ========================================
        
        class PriorityQueue {
            constructor() {
                this.items = [];
            }
            
            enqueue(element, priority) {
                const item = { element, priority };
                let added = false;
                
                for (let i = 0; i < this.items.length; i++) {
                    if (item.priority < this.items[i].priority) {
                        this.items.splice(i, 0, item);
                        added = true;
                        break;
                    }
                }
                
                if (!added) {
                    this.items.push(item);
                }
            }
            
            dequeue() {
                return this.items.shift();
            }
            
            isEmpty() {
                return this.items.length === 0;
            }
        }

        function dijkstra(graph, startId, endId) {
            console.log(`üöÄ –ó–∞–ø—É—Å–∫ –∞–ª–≥–æ—Ä–∏—Ç–º–∞ Dijkstra: ${startId} -> ${endId}`);
            
            const distances = new Map();
            const previous = new Map();
            const visited = new Set();
            const pq = new PriorityQueue();
            
            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
            graph.nodes.forEach((node, id) => {
                distances.set(id, Infinity);
                previous.set(id, null);
            });
            
            distances.set(startId, 0);
            pq.enqueue(startId, 0);
            
            // –û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª Dijkstra
            while (!pq.isEmpty()) {
                const { element: currentId } = pq.dequeue();
                
                if (visited.has(currentId)) continue;
                visited.add(currentId);
                
                if (currentId === endId) break;
                
                const current = graph.nodes.get(currentId);
                
                current.neighbors.forEach(neighbor => {
                    if (visited.has(neighbor.id)) return;
                    
                    // –í—ã—á–∏—Å–ª—è–µ–º —Å—Ç–æ–∏–º–æ—Å—Ç—å —Å —É—á–µ—Ç–æ–º –æ—Å–≤–µ—â–µ–Ω–Ω–æ—Å—Ç–∏
                    const cost = graph.getEdgeCost(neighbor.distance, neighbor.lights);
                    const newDistance = distances.get(currentId) + cost;
                    
                    if (newDistance < distances.get(neighbor.id)) {
                        distances.set(neighbor.id, newDistance);
                        previous.set(neighbor.id, currentId);
                        pq.enqueue(neighbor.id, newDistance);
                    }
                });
            }
            
            // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø—É—Ç—å
            const path = [];
            let current = endId;
            
            while (current !== null) {
                path.unshift(current);
                current = previous.get(current);
            }
            
            if (path[0] !== startId) {
                console.log('‚ùå –ü—É—Ç—å –Ω–µ –Ω–∞–π–¥–µ–Ω!');
                return null;
            }
            
            console.log(`‚úÖ –ü—É—Ç—å –Ω–∞–π–¥–µ–Ω! –î–ª–∏–Ω–∞: ${path.length} —É–∑–ª–æ–≤`);
            return {
                path: path,
                distance: distances.get(endId),
                visited: visited.size
            };
        }

        // ========================================
        // –ò–ù–¢–ï–†–ê–ö–¢–ò–í–ù–´–ô –í–´–ë–û–† –¢–û–ß–ï–ö
        // ========================================
        
        let startMarker = null;
        let endMarker = null;
        let startNodeId = null;
        let endNodeId = null;
        let routePolyline = null;
        let debugMarkers = []; // –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏

        // –ù–∞—Ö–æ–¥–∏–º –±–ª–∏–∂–∞–π—à–∏–π —É–∑–µ–ª –≥—Ä–∞—Ñ–∞ –∫ –∫–ª–∏–∫—É
        function findNearestNode(lat, lng) {
            if (!graphNodes || graphNodes.length === 0) {
                console.error('‚ùå graphNodes –ø—É—Å—Ç–æ–π –∏–ª–∏ –Ω–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω!');
                return null;
            }
            
            let nearest = null;
            let minDist = Infinity;
            
            console.log(`üîç –ü–æ–∏—Å–∫ –±–ª–∏–∂–∞–π—à–µ–≥–æ —É–∑–ª–∞ –¥–ª—è –∫–ª–∏–∫–∞: lat=${lat.toFixed(5)}, lng=${lng.toFixed(5)}`);
            console.log(`   –î–æ—Å—Ç—É–ø–Ω–æ —É–∑–ª–æ–≤: ${graphNodes.length}`);
            
            graphNodes.forEach(node => {
                const dist = getDistance(lat, lng, node.lat, node.lng);
                if (dist < minDist) {
                    minDist = dist;
                    nearest = node;
                }
            });
            
            if (nearest) {
                console.log(`‚úÖ –ù–∞–π–¥–µ–Ω —É–∑–µ–ª #${nearest.id}, —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ: ${(minDist * 1000).toFixed(1)}–º`);
                console.log(`   –ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —É–∑–ª–∞: lat=${nearest.lat.toFixed(5)}, lng=${nearest.lng.toFixed(5)}`);
            }
            
            return nearest;
        }

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –≥—Ä–∞—Ñ –≥–æ—Ç–æ–≤ –ø–µ—Ä–µ–¥ —É—Å—Ç–∞–Ω–æ–≤–∫–æ–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∞
        console.log(`üîß –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–µ—Ä–µ–¥ —É—Å—Ç–∞–Ω–æ–≤–∫–æ–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∞ –∫–ª–∏–∫–æ–≤:`);
        console.log(`   graphNodes —Å—É—â–µ—Å—Ç–≤—É–µ—Ç: ${!!graphNodes}`);
        console.log(`   graphNodes.length: ${graphNodes ? graphNodes.length : 'undefined'}`);
        console.log(`   roadGraph —Å—É—â–µ—Å—Ç–≤—É–µ—Ç: ${!!roadGraph}`);
        console.log(`   map —Å—É—â–µ—Å—Ç–≤—É–µ—Ç: ${!!map}`);
        
        if (!graphNodes || graphNodes.length === 0) {
            console.error('‚ùå –ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –û–®–ò–ë–ö–ê: graphNodes –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω!');
            alert('–û–®–ò–ë–ö–ê: –ì—Ä–∞—Ñ –¥–æ—Ä–æ–≥ –Ω–µ –±—ã–ª —Å–æ–∑–¥–∞–Ω! –ü–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç–µ —Å—Ç—Ä–∞–Ω–∏—Ü—É.');
        } else {
            console.log('‚úÖ –í—Å–µ –≥–æ—Ç–æ–≤–æ –¥–ª—è —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∞ –∫–ª–∏–∫–æ–≤');
        }

        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–ª–∏–∫–æ–≤ –ø–æ –∫–∞—Ä—Ç–µ
        map.on('click', function(e) {
            console.log(`\nüñ±Ô∏è === –ö–õ–ò–ö –ù–ê –ö–ê–†–¢–ï ===`);
            const clickLat = e.latlng.lat;
            const clickLng = e.latlng.lng;
            
            console.log(`   –ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –∫–ª–∏–∫–∞: lat=${clickLat.toFixed(5)}, lng=${clickLng.toFixed(5)}`);
            
            const nearestNode = findNearestNode(clickLat, clickLng);
            
            if (!nearestNode) {
                console.error('‚ùå –ù–µ –Ω–∞–π–¥–µ–Ω –±–ª–∏–∂–∞–π—à–∏–π —É–∑–µ–ª!');
                alert('‚ùå –û—à–∏–±–∫–∞: –Ω–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ –±–ª–∏–∂–∞–π—à—É—é —Ç–æ—á–∫—É –Ω–∞ –¥–æ—Ä–æ–≥–µ!\n\n–ü–æ–ø—Ä–æ–±—É–π—Ç–µ:\n1. –ü–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç—å —Å—Ç—Ä–∞–Ω–∏—Ü—É\n2. –ö–ª–∏–∫–Ω—É—Ç—å –≤ –¥—Ä—É–≥–æ–º –º–µ—Å—Ç–µ');
                return;
            }
            
            if (!startMarker) {
                // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å—Ç–∞—Ä—Ç
                console.log('üü¢ –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –°–¢–ê–†–¢–û–í–û–ô —Ç–æ—á–∫–∏');
                
                startMarker = L.marker([nearestNode.lat, nearestNode.lng], {
                    icon: L.divIcon({
                        className: 'custom-marker-start',
                        html: '<div style="background: #34c759; width: 24px; height: 24px; border-radius: 50%; border: 4px solid white; box-shadow: 0 2px 8px rgba(52, 199, 89, 0.4);"></div>',
                        iconSize: [24, 24],
                        iconAnchor: [12, 12]
                    }),
                    zIndexOffset: 1000
                }).addTo(map);
                
                startNodeId = nearestNode.id;
                document.getElementById('startPoint').value = `–£–∑–µ–ª #${nearestNode.id} (${nearestNode.lat.toFixed(4)}, ${nearestNode.lng.toFixed(4)})`;
                
                console.log(`‚úÖ –°—Ç–∞—Ä—Ç —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω: —É–∑–µ–ª #${startNodeId}`);
                
            } else if (!endMarker) {
                // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∫–æ–Ω–µ—Ü
                console.log('üî¥ –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –ö–û–ù–ï–ß–ù–û–ô —Ç–æ—á–∫–∏');
                
                endMarker = L.marker([nearestNode.lat, nearestNode.lng], {
                    icon: L.divIcon({
                        className: 'custom-marker-end',
                        html: '<div style="background: #ff3b30; width: 24px; height: 24px; border-radius: 50%; border: 4px solid white; box-shadow: 0 2px 8px rgba(255, 59, 48, 0.4);"></div>',
                        iconSize: [24, 24],
                        iconAnchor: [12, 12]
                    }),
                    zIndexOffset: 1000
                }).addTo(map);
                
                endNodeId = nearestNode.id;
                document.getElementById('endPoint').value = `–£–∑–µ–ª #${nearestNode.id} (${nearestNode.lat.toFixed(4)}, ${nearestNode.lng.toFixed(4)})`;
                
                console.log(`‚úÖ –ö–æ–Ω–µ—Ü —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω: —É–∑–µ–ª #${endNodeId}`);
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ —Ç–æ—á–∫–∏ —Ä–∞–∑–Ω—ã–µ
                if (startNodeId === endNodeId) {
                    console.warn('‚ö†Ô∏è –ù–∞—á–∞–ª—å–Ω–∞—è –∏ –∫–æ–Ω–µ—á–Ω–∞—è —Ç–æ—á–∫–∏ —Å–æ–≤–ø–∞–¥–∞—é—Ç!');
                    alert('‚ö†Ô∏è –í—ã–±–µ—Ä–∏—Ç–µ —Ä–∞–∑–Ω—ã–µ —Ç–æ—á–∫–∏ –¥–ª—è –Ω–∞—á–∞–ª–∞ –∏ –∫–æ–Ω—Ü–∞ –º–∞—Ä—à—Ä—É—Ç–∞!');
                    map.removeLayer(endMarker);
                    endMarker = null;
                    endNodeId = null;
                    document.getElementById('endPoint').value = '';
                    return;
                }
                
                // –ê–∫—Ç–∏–≤–∏—Ä—É–µ–º –∫–Ω–æ–ø–∫—É —Ä–∞—Å—á–µ—Ç–∞
                document.getElementById('calculateBtn').disabled = false;
                console.log('‚úÖ –û–±–µ —Ç–æ—á–∫–∏ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã, –∫–Ω–æ–ø–∫–∞ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–∞');
            } else {
                console.log('‚ö†Ô∏è –û–±–µ —Ç–æ—á–∫–∏ —É–∂–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ Reset –¥–ª—è —Å–±—Ä–æ—Å–∞.');
            }
        });

        // ========================================
        // –†–ê–°–ß–ï–¢ –ú–ê–†–®–†–£–¢–ê DIJKSTRA
        // ========================================
        
        function calculateDijkstraRoute() {
            console.log('üöÄ –ù–ê–ß–ê–õ–û –†–ê–°–ß–ï–¢–ê –ú–ê–†–®–†–£–¢–ê');
            console.log(`   –°—Ç–∞—Ä—Ç: —É–∑–µ–ª #${startNodeId}`);
            console.log(`   –ö–æ–Ω–µ—Ü: —É–∑–µ–ª #${endNodeId}`);
            
            if (!startNodeId && startNodeId !== 0) {
                console.error('‚ùå startNodeId –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω!');
                alert('‚ö†Ô∏è –°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏—Ç–µ –ù–ê–ß–ê–õ–¨–ù–£–Æ —Ç–æ—á–∫—É –Ω–∞ –∫–∞—Ä—Ç–µ (–∑–µ–ª–µ–Ω–∞—è)!');
                return;
            }
            
            if (!endNodeId && endNodeId !== 0) {
                console.error('‚ùå endNodeId –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω!');
                alert('‚ö†Ô∏è –¢–µ–ø–µ—Ä—å –≤—ã–±–µ—Ä–∏—Ç–µ –ö–û–ù–ï–ß–ù–£–Æ —Ç–æ—á–∫—É –Ω–∞ –∫–∞—Ä—Ç–µ (–∫—Ä–∞—Å–Ω–∞—è)!');
                return;
            }
            
            const btn = document.getElementById('calculateBtn');
            const originalText = btn.innerHTML;
            btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Dijkstra —Ä–∞–±–æ—Ç–∞–µ—Ç...';
            btn.disabled = true;
            
            // –ó–∞–ø—É—Å–∫–∞–µ–º Dijkstra
            setTimeout(() => {
                console.log('‚öôÔ∏è –ó–∞–ø—É—Å–∫ –∞–ª–≥–æ—Ä–∏—Ç–º–∞ Dijkstra...');
                
                const result = dijkstra(roadGraph, startNodeId, endNodeId);
                
                if (!result || !result.path || result.path.length === 0) {
                    console.error('‚ùå Dijkstra –Ω–µ –Ω–∞—à–µ–ª –ø—É—Ç—å!');
                    console.error('   –†–µ–∑—É–ª—å—Ç–∞—Ç:', result);
                    alert('‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ –ø—É—Ç—å –º–µ–∂–¥—É —Ç–æ—á–∫–∞–º–∏!\n\n–í–æ–∑–º–æ–∂–Ω—ã–µ –ø—Ä–∏—á–∏–Ω—ã:\n- –¢–æ—á–∫–∏ –≤ —Ä–∞–∑–Ω—ã—Ö –Ω–µ—Å–≤—è–∑–∞–Ω–Ω—ã—Ö —á–∞—Å—Ç—è—Ö –≥—Ä–∞—Ñ–∞\n- –ì—Ä–∞—Ñ –ø–æ–≤—Ä–µ–∂–¥–µ–Ω\n\n–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –≤—ã–±—Ä–∞—Ç—å –¥—Ä—É–≥–∏–µ —Ç–æ—á–∫–∏ –±–ª–∏–∂–µ –¥—Ä—É–≥ –∫ –¥—Ä—É–≥—É.');
                    btn.innerHTML = originalText;
                    btn.disabled = false;
                    return;
                }
                
                console.log(`‚úÖ –ü—É—Ç—å –Ω–∞–π–¥–µ–Ω! –î–ª–∏–Ω–∞: ${result.path.length} —É–∑–ª–æ–≤`);
                console.log(`   –°—Ç–æ–∏–º–æ—Å—Ç—å: ${result.distance.toFixed(4)}`);
                console.log(`   –ü—Ä–æ–≤–µ—Ä–µ–Ω–æ —É–∑–ª–æ–≤: ${result.visited}`);
                
                // –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–π –º–∞—Ä—à—Ä—É—Ç
                if (routePolyline) {
                    map.removeLayer(routePolyline);
                }
                
                // –°—Ç—Ä–æ–∏–º –º–∞—Ä—à—Ä—É—Ç –Ω–∞ –∫–∞—Ä—Ç–µ
                const pathCoords = result.path.map(nodeId => {
                    const node = roadGraph.nodes.get(nodeId);
                    if (!node) {
                        console.error(`‚ùå –£–∑–µ–ª #${nodeId} –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –≥—Ä–∞—Ñ–µ!`);
                        return null;
                    }
                    return [node.lat, node.lng];
                }).filter(coord => coord !== null);
                
                if (pathCoords.length === 0) {
                    console.error('‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ—Å—Ç—Ä–æ–∏—Ç—å –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –ø—É—Ç–∏!');
                    alert('‚ùå –û—à–∏–±–∫–∞ –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏—è –º–∞—Ä—à—Ä—É—Ç–∞!');
                    btn.innerHTML = originalText;
                    btn.disabled = false;
                    return;
                }
                
                console.log(`üìç –ü–æ—Å—Ç—Ä–æ–µ–Ω–æ ${pathCoords.length} —Ç–æ—á–µ–∫ –º–∞—Ä—à—Ä—É—Ç–∞`);
                
                routePolyline = L.polyline(pathCoords, {
                    color: '#007aff',
                    weight: 7,
                    opacity: 0.9,
                    dashArray: '12, 8',
                    lineCap: 'round',
                    lineJoin: 'round'
                }).addTo(map);
                
                // –ê–Ω–∏–º–∞—Ü–∏—è –º–∞—Ä—à—Ä—É—Ç–∞
                let offset = 0;
                const animInterval = setInterval(() => {
                    if (!routePolyline || !map.hasLayer(routePolyline)) {
                        clearInterval(animInterval);
                        return;
                    }
                    offset = (offset + 1) % 20;
                    routePolyline.setStyle({
                        dashOffset: -offset
                    });
                }, 50);
                
                // –ü–æ–¥–≥–æ–Ω—è–µ–º –∫–∞—Ä—Ç—É –ø–æ–¥ –º–∞—Ä—à—Ä—É—Ç
                try {
                    map.fitBounds(routePolyline.getBounds(), {
                        padding: [60, 60],
                        maxZoom: 15
                    });
                } catch (e) {
                    console.warn('‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥–æ–≥–Ω–∞—Ç—å –∫–∞—Ä—Ç—É:', e);
                }
                
                // –í—ã—á–∏—Å–ª—è–µ–º —Ä–µ–∞–ª—å–Ω–æ–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –ø–æ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞–º
                let realDistance = 0;
                for (let i = 0; i < pathCoords.length - 1; i++) {
                    realDistance += getDistance(
                        pathCoords[i][0], pathCoords[i][1],
                        pathCoords[i+1][0], pathCoords[i+1][1]
                    );
                }
                
                const totalDistance = Math.round(realDistance * 1000); // –≤ –º–µ—Ç—Ä–∞—Ö
                const walkingTime = Math.ceil(totalDistance / 80); // –º–∏–Ω—É—Ç—ã (80–º/–º–∏–Ω)
                const lightsOnRoute = countLightsAlongRoute(pathCoords);
                const avgLightsPerSegment = (lightsOnRoute / (pathCoords.length - 1)).toFixed(1);
                
                // –û—Ü–µ–Ω–∫–∞ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏: –±–æ–ª—å—à–µ —Å–≤–µ—Ç–∞ = –±–µ–∑–æ–ø–∞—Å–Ω–µ–µ
                let safetyScore = 0;
                if (avgLightsPerSegment >= 15) safetyScore = 95;
                else if (avgLightsPerSegment >= 10) safetyScore = 85;
                else if (avgLightsPerSegment >= 7) safetyScore = 75;
                else if (avgLightsPerSegment >= 5) safetyScore = 65;
                else if (avgLightsPerSegment >= 3) safetyScore = 50;
                else safetyScore = 30;
                
                console.log(`üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:`);
                console.log(`   –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ: ${totalDistance}–º`);
                console.log(`   –í—Ä–µ–º—è: ${walkingTime} –º–∏–Ω`);
                console.log(`   –§–æ–Ω–∞—Ä–µ–π: ${lightsOnRoute}`);
                console.log(`   –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å: ${safetyScore}%`);
                
                // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é
                const routeInfo = document.getElementById('routeInfo');
                const routeDetails = document.getElementById('routeDetails');
                
                routeDetails.innerHTML = `
                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem; margin-top: 0.5rem;">
                        <div><strong>Vzd√°lenost:</strong> ${totalDistance} m</div>
                        <div><strong>ƒåas:</strong> ~${walkingTime} min pƒõ≈°ky</div>
                        <div><strong>Svƒõtel na trase:</strong> ${lightsOnRoute} ks</div>
                        <div><strong>Bezpeƒçnost:</strong> ${safetyScore}%</div>
                        <div><strong>Zkontrolov√°no uzl≈Ø:</strong> ${result.visited}</div>
                        <div><strong>Bod≈Ø v trase:</strong> ${pathCoords.length}</div>
                    </div>
                    <div style="margin-top: 1rem; padding: 0.75rem; background: rgba(52, 199, 89, 0.1); border-left: 3px solid #34c759; border-radius: 4px;">
                        <strong style="color: #34c759;">Trasa nalezena</strong><br>
                        <span style="font-size: 0.9rem; color: var(--text-secondary);">
                            Algoritmus Dijkstra vybral ${safetyScore >= 75 ? 'velmi bezpeƒçnou' : safetyScore >= 50 ? 'bezpeƒçnou' : 'relativnƒõ bezpeƒçnou'} 
                            cestu s pr≈Ømƒõrnƒõ ${avgLightsPerSegment} svƒõtel na √∫sek.
                        </span>
                    </div>
                `;
                
                routeInfo.style.display = 'block';
                
                btn.innerHTML = originalText;
                btn.disabled = false;
                
                console.log('‚úÖ –ú–∞—Ä—à—Ä—É—Ç —É—Å–ø–µ—à–Ω–æ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω –Ω–∞ –∫–∞—Ä—Ç–µ!');
            }, 600);
        }

        // –ü–æ–¥—Å—á–µ—Ç —Ñ–æ–Ω–∞—Ä–µ–π –≤–¥–æ–ª—å –º–∞—Ä—à—Ä—É—Ç–∞
        function countLightsAlongRoute(pathCoords) {
            const threshold = 0.00025; // ~25 –º–µ—Ç—Ä–æ–≤
            let count = 0;
            
            streetLights.forEach(light => {
                for (let i = 0; i < pathCoords.length - 1; i++) {
                    const dist = distanceToSegment(
                        light.lat, light.lng,
                        pathCoords[i][0], pathCoords[i][1],
                        pathCoords[i+1][0], pathCoords[i+1][1]
                    );
                    
                    if (dist < threshold) {
                        count += light.intensity; // —É—á–∏—Ç—ã–≤–∞–µ–º —è—Ä–∫–æ—Å—Ç—å
                        break;
                    }
                }
            });
            
            return Math.round(count);
        }

        // ========================================
        // –§–£–ù–ö–¶–ò–Ø –°–ë–†–û–°–ê
        // ========================================
        
        function resetRoute() {
            console.log('üîÑ –°–±—Ä–æ—Å –º–∞—Ä—à—Ä—É—Ç–∞...');
            
            if (startMarker) {
                map.removeLayer(startMarker);
                startMarker = null;
                startNodeId = null;
            }
            
            if (endMarker) {
                map.removeLayer(endMarker);
                endMarker = null;
                endNodeId = null;
            }
            
            if (routePolyline) {
                map.removeLayer(routePolyline);
                routePolyline = null;
            }
            
            // –û—á–∏—â–∞–µ–º debug –º–∞—Ä–∫–µ—Ä—ã –µ—Å–ª–∏ –µ—Å—Ç—å
            debugMarkers.forEach(m => map.removeLayer(m));
            debugMarkers = [];
            
            document.getElementById('startPoint').value = '';
            document.getElementById('endPoint').value = '';
            document.getElementById('calculateBtn').disabled = true;
            document.getElementById('routeInfo').style.display = 'none';
            
            map.setView([49.7384, 13.3736], 14);
            
            console.log('‚úÖ –°–±—Ä–æ—Å –∑–∞–≤–µ—Ä—à–µ–Ω');
        }

        // ========================================
        // Smooth scrolling
        // ========================================
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function(e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    window.scrollTo({
                        top: target.offsetTop - 100,
                        behavior: 'smooth'
                    });
                }
            });
        });

        // Animace p≈ôi naƒçten√≠
        console.log('üöÄ Bezpeƒçn√© Trasy Plznƒõ - LOADED!');
        console.log('üìä Celkem sv√≠tidel:', plzenData.lights.reduce((a, b) => a + b, 0));
        console.log('‚ö†Ô∏è Celkem kriminality:', plzenData.crime.reduce((a, b) => a + b, 0), 'incident≈Ø/rok');
    </script>
</body>
</html>
